{"version":3,"sources":["webpack:///./resources/js/prefetch.js"],"names":["toPrefetch","Set","alreadyPrefetched","prefetcher","document","createElement","isNativePrefetchSupported","relList","supports","prefetchWithTimeout","navigator","connection","saveData","effectiveType","includes","userAgent","indexOf","url","timer","setTimeout","stopPreloading","Promise","resolve","reject","link","rel","href","onload","onerror","head","appendChild","req","XMLHttpRequest","open","withCredentials","status","send","prefetch","clearTimeout","addUrlToQueue","processImmediately","has","origin","window","location","substring","length","i","FPConfig","ignoreKeywords","add","linksObserver","IntersectionObserver","entries","forEach","entry","isIntersecting","target","maxRPS","hoverTimer","mouseOverListener","event","elm","closest","hoverDelay","touchStartListener","mouseOutListener","requestIdleCallback","querySelectorAll","e","unobserve","clear","removeEventListener"],"mappings":"mHAAA,IAAMA,EAAa,IAAIC,IACjBC,EAAoB,IAAID,IAGxBE,EAAaC,SAASC,cAAc,QACpCC,EACJH,EAAWI,SACXJ,EAAWI,QAAQC,UACnBL,EAAWI,QAAQC,SAAS,YAsCxBC,GAlCJC,UAAUC,aACTD,UAAUC,WAAWC,WACnBF,UAAUC,WAAWE,eAAiB,IAAIC,SAAS,OAItDJ,UAAUK,UAAUC,QAAQ,UAAY,GACxCN,UAAUK,UAAUC,QAAQ,YA2BF,SAAAC,GAC1B,IAAMC,EAAQC,YAAW,kBAAMC,MAAkB,MAzBlC,SAAAH,GAEf,OACS,IAAII,QADTf,EACiB,SAACgB,EAASC,GAC3B,IAAMC,EAAOpB,SAASC,cAAT,QACbmB,EAAKC,IAAL,WACAD,EAAKE,KAAOT,EACZO,EAAKG,OAASL,EACdE,EAAKI,QAAUL,EACfnB,SAASyB,KAAKC,YAAYN,IAIX,SAACF,EAASC,GAC3B,IAAMQ,EAAM,IAAIC,eAChBD,EAAIE,KAAJ,MAAgBhB,EAAMc,EAAIG,iBAAkB,GAC5CH,EAAIJ,OAAS,WACI,MAAfI,EAAII,OAAiBb,IAAYC,KAEnCQ,EAAIK,UAONC,CAASpB,GAAT,OACS,kBAAMG,OADf,SAEW,kBAAMkB,aAAapB,QAG1BqB,EAAgB,SAACtB,GAAoC,IAA/BuB,EAA+B,wDACzD,IAAItC,EAAkBuC,IAAIxB,KAAQjB,EAAWyC,IAAIxB,GAAjD,CAGA,IAAMyB,EAASC,OAAOC,SAASF,OAC/B,GAAIzB,EAAI4B,UAAU,EAAGH,EAAOI,UAAYJ,GAGpCC,OAAOC,SAASlB,OAAST,EAA7B,CAGA,IAAK,IAAI8B,EAAI,EAAGA,EAAIJ,OAAOK,SAASC,eAAeH,OAAQC,IACzD,GAAI9B,EAAIH,SAAS6B,OAAOK,SAASC,eAAeF,IAAK,OAInDP,GACF/B,EAAoBQ,GACpBf,EAAkBgD,IAAIjC,IACjBjB,EAAWkD,IAAIjC,MAIlBkC,EAAgB,IAAIC,sBAAqB,SAAAC,GAC7CA,EAAQC,SAAQ,SAAAC,GACd,GAAIA,EAAMC,eAAgB,CACxB,IAAMvC,EAAMsC,EAAME,OAAO/B,KACzBa,EAActB,GAAM0B,OAAOK,SAASU,eAiBtCC,EAAa,KAGXC,EAAoB,SAAAC,GACxB,IAAMC,EAAMD,EAAMJ,OAAOM,QAAQ,KAC7BD,GAAOA,EAAIpC,OAASxB,EAAkBuC,IAAIqB,EAAIpC,QAChDiC,EAAaxC,YAAW,WACtBoB,EAAcuB,EAAIpC,MAAM,KACvBiB,OAAOK,SAASgB,cAKjBC,EAAqB,SAAAJ,GACzB,IAAMC,EAAMD,EAAMJ,OAAOM,QAAQ,KAC7BD,GAAOA,EAAIpC,OAASxB,EAAkBuC,IAAIqB,EAAIpC,OAChDa,EAAcuB,EAAIpC,MAAM,IAItBwC,EAAmB,SAAAL,GACvB,IAAMC,EAAMD,EAAMJ,OAAOM,QAAQ,KAC7BD,GAAOA,EAAIpC,OAASxB,EAAkBuC,IAAIqB,EAAIpC,OAChDY,aAAaqB,IAoBXvC,GAdJuB,OAAOwB,oBAcc,WAErB/D,SAASgE,iBAAiB,KAAKd,SAAQ,SAAAe,GAAC,OAAIlB,EAAcmB,UAAUD,MAGpErE,EAAWuE,QAGXnE,SAASoE,oBAAoB,YAAaZ,GAAmB,GAC7DxD,SAASoE,oBAAoB,WAAYN,GAAkB,GAC3D9D,SAASoE,oBAAoB,aAAcP,GAAoB,O","file":"/js/prefetch.js","sourcesContent":["const toPrefetch = new Set();\nconst alreadyPrefetched = new Set();\n\n// Check browser support for native 'prefetch'\nconst prefetcher = document.createElement(\"link\");\nconst isNativePrefetchSupported =\n  prefetcher.relList &&\n  prefetcher.relList.supports &&\n  prefetcher.relList.supports(\"prefetch\");\n\n// Checks if user is on slow connection or have enabled data saver\nconst isSlowConnection =\n  navigator.connection &&\n  (navigator.connection.saveData ||\n    (navigator.connection.effectiveType || \"\").includes(\"2g\"));\n\n// Check browser is IE\nconst isIE =\n  navigator.userAgent.indexOf(\"MSIE \") > -1 ||\n  navigator.userAgent.indexOf(\"Trident/\") > -1;\n\n// Prefetch the given url using native 'prefetch'. Fallback to 'xhr' if not supported\nconst prefetch = url => {\n  // Prefetch using native prefetch\n  if (isNativePrefetchSupported) {\n    return new Promise((resolve, reject) => {\n      const link = document.createElement(`link`);\n      link.rel = `prefetch`;\n      link.href = url;\n      link.onload = resolve;\n      link.onerror = reject;\n      document.head.appendChild(link);\n    });\n  }\n  // Pretch using xhr\n  return new Promise((resolve, reject) => {\n    const req = new XMLHttpRequest();\n    req.open(`GET`, url, (req.withCredentials = true));\n    req.onload = () => {\n      req.status === 200 ? resolve() : reject();\n    };\n    req.send();\n  });\n};\n\n// Prefetch pages with a default timeout\nconst prefetchWithTimeout = url => {\n  const timer = setTimeout(() => stopPreloading(), 5000);\n  prefetch(url)\n    .catch(() => stopPreloading())\n    .finally(() => clearTimeout(timer));\n};\n\nconst addUrlToQueue = (url, processImmediately = false) => {\n  if (alreadyPrefetched.has(url) || toPrefetch.has(url)) return;\n\n  // Prevent preloading 3rd party domains\n  const origin = window.location.origin;\n  if (url.substring(0, origin.length) !== origin) return;\n\n  // Prevent current page from preloading\n  if (window.location.href === url) return;\n\n  // Ignore keywords in the array, if matched to the url\n  for (let i = 0; i < window.FPConfig.ignoreKeywords.length; i++) {\n    if (url.includes(window.FPConfig.ignoreKeywords[i])) return;\n  }\n\n  // If max RPS is 0 or is on mouse hover, process immediately (without queue)\n  if (processImmediately) {\n    prefetchWithTimeout(url);\n    alreadyPrefetched.add(url);\n  } else toPrefetch.add(url);\n};\n\n// Observe the links in viewport, add url to queue if found intersecting\nconst linksObserver = new IntersectionObserver(entries => {\n  entries.forEach(entry => {\n    if (entry.isIntersecting) {\n      const url = entry.target.href;\n      addUrlToQueue(url, !window.FPConfig.maxRPS);\n    }\n  });\n});\n\n// Queue that process requests based on max RPS (requests per second)\nconst startQueue = () =>\n  setInterval(() => {\n    Array.from(toPrefetch)\n      .slice(0, window.FPConfig.maxRPS)\n      .forEach(url => {\n        prefetchWithTimeout(url);\n        alreadyPrefetched.add(url);\n        toPrefetch.delete(url);\n      });\n  }, 1000);\n\nlet hoverTimer = null;\n\n// Add URL to queue on mouse hover, after timeout\nconst mouseOverListener = event => {\n  const elm = event.target.closest(\"a\");\n  if (elm && elm.href && !alreadyPrefetched.has(elm.href)) {\n    hoverTimer = setTimeout(() => {\n      addUrlToQueue(elm.href, true);\n    }, window.FPConfig.hoverDelay);\n  }\n};\n\n// Preload on touchstart on mobile\nconst touchStartListener = event => {\n  const elm = event.target.closest(\"a\");\n  if (elm && elm.href && !alreadyPrefetched.has(elm.href))\n    addUrlToQueue(elm.href, true);\n};\n\n// Clear timeout on mouse out if not already preloaded\nconst mouseOutListener = event => {\n  const elm = event.target.closest(\"a\");\n  if (elm && elm.href && !alreadyPrefetched.has(elm.href)) {\n    clearTimeout(hoverTimer);\n  }\n};\n\n// Fallback for requestIdleCallback https://caniuse.com/#search=requestIdleCallback\nconst requestIdleCallback =\n  window.requestIdleCallback ||\n  function(cb) {\n    const start = Date.now();\n    return setTimeout(function() {\n      cb({\n        didTimeout: false,\n        timeRemaining: function() {\n          return Math.max(0, 50 - (Date.now() - start));\n        }\n      });\n    }, 1);\n  };\n\n// Stop preloading in case server is responding slow/errors\nconst stopPreloading = () => {\n  // Find all links are remove it from observer (viewport)\n  document.querySelectorAll(\"a\").forEach(e => linksObserver.unobserve(e));\n\n  // Clear pending links in queue\n  toPrefetch.clear();\n\n  // Remove event listeners for mouse hover and mobile touch\n  document.removeEventListener(\"mouseover\", mouseOverListener, true);\n  document.removeEventListener(\"mouseout\", mouseOutListener, true);\n  document.removeEventListener(\"touchstart\", touchStartListener, true);\n};\n\nfunction flyingPages(options = {}) {\n  // Don't start preloading if user is on a slow connection or browser is IE\n  if (isSlowConnection || isIE) return;\n\n  // Default options incase options is not set\n  const defaultOptions = {\n    delay: 0,\n    ignoreKeywords: [],\n    maxRPS: 3,\n    hoverDelay: 50\n  };\n\n  // Combine default options with received options to create the new config and set the config in window for easy access\n  window.FPConfig = Object.assign(defaultOptions, options);\n\n  // Start Queue\n  startQueue();\n\n  // Start preloading links in viewport on idle callback, with a delay\n  requestIdleCallback(() =>\n    setTimeout(\n      () =>\n        document.querySelectorAll(\"a\").forEach(e => linksObserver.observe(e)),\n      window.FPConfig.delay * 1000\n    )\n  );\n\n  // Add event listeners to detect mouse hover and mobile touch\n  const listenerOptions = { capture: true, passive: true };\n  document.addEventListener(\"mouseover\", mouseOverListener, listenerOptions);\n  document.addEventListener(\"mouseout\", mouseOutListener, listenerOptions);\n  document.addEventListener(\"touchstart\", touchStartListener, listenerOptions);\n}\n"],"sourceRoot":""}