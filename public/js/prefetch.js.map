{"version":3,"sources":["webpack:///./resources/js/helper/prefetch.js"],"names":["toPrefetch","Set","alreadyPrefetched","prefetcher","document","createElement","isSupported","relList","supports","window","IntersectionObserver","IntersectionObserverEntry","prototype","navigator","connection","saveData","effectiveType","includes","prefetchWithTimeout","url","timer","setTimeout","stopPreloading","Promise","resolve","reject","link","rel","href","onload","onerror","head","appendChild","prefetch","clearTimeout","addUrlToQueue","processImmediately","has","origin","location","substring","length","i","FPConfig","ignoreKeywords","add","linksObserver","entries","forEach","entry","isIntersecting","target","maxRPS","hoverTimer","mouseOverListener","event","elm","closest","hoverDelay","touchStartListener","mouseOutListener","requestIdleCallback","cb","start","Date","now","didTimeout","timeRemaining","Math","max","querySelectorAll","e","unobserve","clear","removeEventListener","Object","assign","delay","setInterval","Array","from","slice","observe","listenerOptions","capture","passive","addEventListener","prefetchPages"],"mappings":"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","file":"/js/prefetch.js","sourcesContent":["function prefetchPages() {\n  const toPrefetch = new Set()\n  const alreadyPrefetched = new Set()\n\n  // Check browser support for native 'prefetch'\n  const prefetcher = document.createElement('link')\n  const isSupported =\n    prefetcher.relList &&\n    prefetcher.relList.supports &&\n    prefetcher.relList.supports('prefetch') &&\n    window.IntersectionObserver &&\n    'isIntersecting' in IntersectionObserverEntry.prototype\n\n  // Checks if user is on slow connection or has enabled data saver\n  const isSlowConnection =\n    navigator.connection && (navigator.connection.saveData || (navigator.connection.effectiveType || '').includes('2g'))\n\n  // Don't start preloading if user is on a slow connection or not supported\n  if (isSlowConnection || !isSupported) return\n\n  // Prefetch the given url using native 'prefetch'. Fallback to 'xhr' if not supported\n  const prefetch = url =>\n    new Promise((resolve, reject) => {\n      const link = document.createElement(`link`)\n      link.rel = `prefetch`\n      link.href = url\n      link.onload = resolve\n      link.onerror = reject\n      document.head.appendChild(link)\n    })\n\n  // Prefetch pages with a timeout\n  const prefetchWithTimeout = url => {\n    const timer = setTimeout(() => stopPreloading(), 5000)\n    prefetch(url)\n      .catch(() => stopPreloading())\n      .finally(() => clearTimeout(timer))\n  }\n\n  const addUrlToQueue = (url, processImmediately = false) => {\n    if (alreadyPrefetched.has(url) || toPrefetch.has(url)) return\n\n    // Prevent preloading 3rd party domains\n    const origin = window.location.origin\n    if (url.substring(0, origin.length) !== origin) return\n\n    // Prevent current page from preloading\n    if (window.location.href === url) return\n\n    // Ignore keywords in the array, if matched to the url\n    for (let i = 0; i < window.FPConfig.ignoreKeywords.length; i++) {\n      if (url.includes(window.FPConfig.ignoreKeywords[i])) return\n    }\n\n    // If max RPS is 0 or is on mouse hover, process immediately (without queue)\n    if (processImmediately) {\n      prefetchWithTimeout(url)\n      alreadyPrefetched.add(url)\n    } else toPrefetch.add(url)\n  }\n\n  // Observe the links in viewport, add url to queue if found intersecting\n  const linksObserver = new IntersectionObserver(entries => {\n    entries.forEach(entry => {\n      if (entry.isIntersecting) {\n        const url = entry.target.href\n        addUrlToQueue(url, !window.FPConfig.maxRPS)\n      }\n    })\n  })\n\n  // Queue that process requests based on max RPS (requests per second)\n  const startQueue = () =>\n    setInterval(() => {\n      Array.from(toPrefetch)\n        .slice(0, window.FPConfig.maxRPS)\n        .forEach(url => {\n          prefetchWithTimeout(url)\n          alreadyPrefetched.add(url)\n          toPrefetch.delete(url)\n        })\n    }, 1000)\n\n  let hoverTimer = null\n\n  // Add URL to queue on mouse hover, after timeout\n  const mouseOverListener = event => {\n    const elm = event.target.closest('a:not(.no-pre)')\n    if (elm && elm.href && !alreadyPrefetched.has(elm.href)) {\n      hoverTimer = setTimeout(() => {\n        addUrlToQueue(elm.href, true)\n      }, window.FPConfig.hoverDelay)\n    }\n  }\n\n  // Preload on touchstart on mobile\n  const touchStartListener = event => {\n    const elm = event.target.closest('a:not(.no-pre)')\n    if (elm && elm.href && !alreadyPrefetched.has(elm.href)) addUrlToQueue(elm.href, true)\n  }\n\n  // Clear timeout on mouse out if not already preloaded\n  const mouseOutListener = event => {\n    const elm = event.target.closest('a:not(.no-pre)')\n    if (elm && elm.href && !alreadyPrefetched.has(elm.href)) {\n      clearTimeout(hoverTimer)\n    }\n  }\n\n  // Fallback for requestIdleCallback https://caniuse.com/#search=requestIdleCallback\n  const requestIdleCallback =\n    window.requestIdleCallback ||\n    function(cb) {\n      const start = Date.now()\n      return setTimeout(function() {\n        cb({\n          didTimeout: false,\n          timeRemaining: function() {\n            return Math.max(0, 50 - (Date.now() - start))\n          },\n        })\n      }, 1)\n    }\n\n  // Stop preloading in case server is responding slow/errors\n  const stopPreloading = () => {\n    // Find all links are remove it from observer (viewport)\n    document.querySelectorAll('a:not(.no-pre)').forEach(e => linksObserver.unobserve(e))\n\n    // Clear pending links in queue\n    toPrefetch.clear()\n\n    // Remove event listeners for mouse hover and mobile touch\n    document.removeEventListener('mouseover', mouseOverListener, true)\n    document.removeEventListener('mouseout', mouseOutListener, true)\n    document.removeEventListener('touchstart', touchStartListener, true)\n  }\n\n  // Default options incase options is not set\n  const defaultOptions = {\n    delay: 0,\n    ignoreKeywords: [],\n    maxRPS: 3,\n    hoverDelay: 50,\n  }\n\n  // Combine default options with received options to create the new config and set the config in window for easy access\n  window.FPConfig = Object.assign(defaultOptions, window.FPConfig)\n\n  // Start Queue\n  startQueue()\n\n  // Start preloading links in viewport on idle callback, with a delay\n  requestIdleCallback(() =>\n    setTimeout(\n      () => document.querySelectorAll('a:not(.no-pre)').forEach(e => linksObserver.observe(e)),\n      window.FPConfig.delay * 1000\n    )\n  )\n\n  // Add event listeners to detect mouse hover and mobile touch\n  const listenerOptions = { capture: true, passive: true }\n  document.addEventListener('mouseover', mouseOverListener, listenerOptions)\n  document.addEventListener('mouseout', mouseOutListener, listenerOptions)\n  document.addEventListener('touchstart', touchStartListener, listenerOptions)\n}\n\nprefetchPages()\n"],"sourceRoot":""}